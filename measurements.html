<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="shortcut icon" href="deca2.png" />
        <title>Measurement</title>
        <link rel="stylesheet" href="math.css" />
    </head>
    <body>
        <img id="image" src="deca.png" align="left" />
        <p>
            The quadrille and mosaic are examples of discrete tilings. These
            tilings use integers, or at worst, rational numbers (quotients of
            integers) to determine the placement of corners and lines. I found
            the current algorithm by doodling pentagons on a quadrille pad
            (graph paper) with each 1/4 inch square represented 4 by 4 units.
            The pentagons were not regular pentagons, but the looked kind of
            close. The consisted of three types of lines and their mirror images
            with slope of 0, 2/3 (33) and 4 (76). Using the three vectors, one
            can draw a reasonable facsimile of a regular pentagon. the first
            three tenths of a circle, they are meant to appoximate the angles, 0
            degree, 36 degrees and 72 degrees. From these angles, the other
            seven values can be derived through changes of sign.
        </p>
        <span align="left">
            <canvas id="quadrille" class="flowtile" align="left"></canvas>
        </span>
        <p>
            Also, there are sequentially larger versions of these vectors based
            somewhat on the fibinacci sequence. The first value always points up
            along the negative y axis. So they are: [0,4], [3, 2] and [4, 1].
            Note that the y value is set to positive to simplify the tables. The
            fibinacci sequence, starting is [0, 1, 1, 2, 3, 5..] where F[n+1] =
            F[n] + F[n + 1] The simple example is [0, 4]. This is the length of
            the base of pentagon[0].
        </p>
        <script type="module" src="penrose.js"></script>
        <script type="module" src="math.js"></script>
        <script type="module">
            console.log(`addEventListner`);
            window.addEventListener("load", () => measureTasks(), false);
            /***
             * This does a fake draw to size things up before resizing the
             * canvas and the targets.
             *
             * Also, lets look at some globals/input params
             * Possible parameters
             *
             * linewidth, strokeStyle
             * scale
             * shapeMode (renderShape comes from this)
             *
             *
             * Postconditions: canvas.width, canvas.height
             * loc : a Point.
             *
             **/
            import { Bounds, outline, penrose, p } from "./penrose.js";
            import { MODE_REAL } from "./math.js";
            import { PenroseScreen } from "./penrose-screen.js";
            //let g;
            //let scale;
            export function measureTasks() {
                console.log(`drawImage`);
                drawQuadrille();
                drawImage();
            }
            let shapeMode;
            let renderShape;
            export function drawQuadrille() {
                const canvas = document.querySelector("#quadrille");
                canvas.width = 0;
                canvas.height = 0;
                let base = p(0, 0);
                const gg = canvas.getContext("2d");
                gg.strokeStyle = penrose.OUTLINE;
                gg.lineWidth = 1;
                let scales = 3.7;
                shapeMode = MODE_REAL;
                let penroseG = new PenroseScreen(gg, scales, shapeMode);
                const deca = penroseG.deca.bind(penroseG);
                //renderShape = outline;
                let fifths;
                let isDown;
                let exp;

                // Now some decagons

                fifths = 0;
                isDown = false;
                base = p(0, 0);
                exp = 2;
                let bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));
                base = base.tr(p(bounds.minPoint.x, bounds.minPoint.y).neg);
                canvas.width = (bounds.maxPoint.x - bounds.minPoint.x) * scales;
                canvas.height =
                    (bounds.maxPoint.y - bounds.minPoint.y) * scales;

                bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));
                bounds = new Bounds();
                const img = canvas.toDataURL("img.png");
            }

            export function drawImage() {
                console.log(`drawImage`);
                const canvas = document.createElement("canvas");
                console.log(`canvas ${canvas}`);
                canvas.width = 0;
                canvas.height = 0;
                let base = p(0, 0);
                let g = canvas.getContext("2d");
                g.strokeStyle = penrose.OUTLINE;
                g.lineWidth = 1;
                let scale = 5;
                let shapeMode = MODE_REAL;
                renderShape = outline;
                let penroseG = new PenroseScreen(g, scale, shapeMode);
                const deca = penroseG.deca.bind(penroseG);

                let fifths;
                let isDown;
                let exp;

                // Now some decagons
                fifths = 0;
                isDown = false;
                base = p(0, 0);
                exp = 1;
                let bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));
                bounds.pad(1);
                base = base.tr(p(bounds.minPoint.x, bounds.minPoint.y).neg);
                canvas.width = (bounds.maxPoint.x - bounds.minPoint.x) * scale;
                canvas.height = (bounds.maxPoint.y - bounds.minPoint.y) * scale;

                bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));
                bounds.pad(1);
                bounds = new Bounds();
                const img = canvas.toDataURL("img.png");
                const ele = document.querySelector("#image");
                console.log(ele.src);
                ele.src = img;
            }
        </script>
    </body>
</html>
