<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="shortcut icon" href="deca2.png" />
        <title>Measurement</title>
        <link rel="stylesheet" href="math.css" />
    </head>
    <body onload="measureTasks()">
        <img src="deca.png" align="left" />
        <p>
            The quadrille and mosaic are examples of discrete tilings. These
            tilings use integers, or at worst, rational numbers (quotients of
            integers) to determine the placement of corners and lines. The
            current algorithm was found by doodling pentagons on a quadrille pad
            (graph paper). The pentagons were not regular pentagons, but the
            looked kind of close. The consisted of three types of lines and
            their mirror images with slope of 0, 2/3 (33) and 4 (76). Using the
            three vectors, one can draw a reasonable facsimile of a regular
            pentagon. the first three tenths of a circle, they are meant to
            appoximate the angles, 0 degree, 36 degrees and 72 degrees. From
            these angles, the other seven values can be derived through changes
            of sign.
        </p>
        <span align="left">
            <canvas id="quadrille" class="flowtile" align="left"></canvas>
        </span>
        <p>
            Also, there are sequentially larger versions of these vectors based
            somewhat on the fibinacci sequence. The first value always points up
            along the negative y axis. So they are: [0,4], [3, 2] and [4, 1].
            Note that the y value is set to positive to simplify the tables. The
            fibinacci sequence, starting is [0, 1, 1, 2, 3, 5..] where F[n+1] =
            F[n] + F[n + 1] The simple example is [0, 4]. This is the length of
            the base of pentagon[0].
        </p>
        <script src="penrose.js"></script>
        <script src="math.js"></script>
        <script>
            function measureTasks() {
                drawQuadrille();
            }

            /***
             * This does a fake draw to size things up before resizing the
             * canvas and the targets.
             *
             * Also, lets look at some globals/input params
             * Possible parameters
             *
             * linewidth, strokeStyle
             * scale
             * shapeMode (renderShape comes from this)
             *
             *
             * Postconditions: canvas.width, canvas.height
             * loc : a Point.
             *
             **/

            function drawQuadrille() {
                const canvas = document.querySelector("#quadrille");
                canvas.width = 0;
                canvas.height = 0;
                let base = p(0, 0);
                g = canvas.getContext("2d");
                g.strokeStyle = penrose.OUTLINE;
                g.lineWidth = 1;
                scale = 3.7;
                shapeMode = MODE_REAL;
                renderShape = outline;

                // [pWheels, sWheels, tWheels, dWheels] = [
                //     real.pWheels,
                //     real.sWheels,
                //     real.tWheels,
                //     real.dWheels,
                // ];

                let fifths;
                let isDown;
                let exp;

                // Now some decagons

                fifths = 0;
                isDown = false;
                base = p(0, 0);
                exp = 2;

                let bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));
                base = base.tr(p(bounds.minPoint.x, bounds.minPoint.y).neg);
                canvas.width = (bounds.maxPoint.x - bounds.minPoint.x) * scale;
                canvas.height = (bounds.maxPoint.y - bounds.minPoint.y) * scale;

                bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));
                console.log(
                    `bounds minX: ${bounds.minPoint.x} minY: ${bounds.minPoint.y}`
                );
                console.log(`min: ${bounds.min}`);

                bounds = new Bounds();
                console.log(`bounds minX: ${bounds.minX} minY: ${bounds.minY}`);
                console.log(`min: ${bounds.min}`);
                const img = canvas.toDataURL("img.png");
                console.log(img);
            }
        </script>
    </body>
</html>
