<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="shortcut icon" href="deca2.png" />
        <title>Measurement</title>
        <link rel="stylesheet" href="math.css" />
    </head>
    <body>
        <h1>Measurements</h1>
        <img id="image" src="deca.png" align="left" />
        <p>
            The quadrille and mosaic are examples of discrete tilings. These
            tilings use integers, or at worst, rational numbers (quotients of
            integers) to determine the placement of corners and lines. I found
            the current algorithm by doodling pentagons on a quadrille pad
            (graph paper) with each 1/4 inch square represented 4 by 4 units.
            The pentagons were not regular pentagons, but the looked kind of
            close. The consisted of three types of lines and their mirror images
            with slope of 0, 2/3 (33) and 4 (76). Using the three vectors, one
            can draw a reasonable facsimile of a regular pentagon. the first
            three tenths of a circle, they are meant to appoximate the angles, 0
            degree, 36 degrees and 72 degrees. From these angles, the other
            seven values can be derived through changes of sign.
        </p>
        <span align="left">
            <canvas id="quadrille" class="flowtile" align="left"></canvas>
        </span>
        <p>
            Also, there are sequentially larger versions of these vectors based
            somewhat on the fibinacci sequence. The first value always points up
            along the negative y axis. So they are: [0,4], [3, 2] and [4, 1].
            Note that the y value is set to positive to simplify the tables. The
            fibinacci sequence, starting is [0, 1, 1, 2, 3, 5..] where F[n+1] =
            F[n] + F[n + 1] The simple example is [0, 4]. This is the length of
            the base of pentagon[0].
        </p>
        <p>
            Everything in the quadrille version so far is based on this base
            pentagon:
            <code>
                const pentaUp = [ [0, -3], [3, -1], [2, 3], [-2, 3], [-3, -1]]
            </code>
        </p>
        <!--

        <script type="module" src="penrose.js"></script>
        <script type="module" src="math.js"></script>
        -->
        <script type="module">
            /***
             * This does a fake draw to size things up before resizing the
             * canvas and the targets.
             *
             * Also, lets look at some globals/input params
             * Possible parameters
             *
             * linewidth, strokeStyle
             * scale
             * shapeMode (renderShape comes from this)
             *
             *
             * Postconditions: canvas.width, canvas.height
             * loc : a Point.
             *
             **/
            import { p } from "./point.js";
            import { Bounds, penrose } from "./penrose.js";
            import { outline } from "./shape-modes.js";
            import { MODE_REAL, iface } from "./math.js";
            import { PenroseScreen } from "./penrose-screen.js";

            window.addEventListener("load", () => measureTasks(), false);
            export function measureTasks() {
                drawQuadrille();
                drawImage();
            }

            function drawQuadrille() {
                const canvas = document.querySelector("#quadrille");
                canvas.width = 0;
                canvas.height = 0;

                const g = canvas.getContext("2d");
                g.strokeStyle = penrose.OUTLINE;
                g.lineWidth = 1;
                const scale = 3.7;
                const shapeMode = MODE_REAL;
                const { deca } = iface(g, scale, shapeMode);

                let base = p(0, 0);
                let fifths = 0;
                let isDown = false;
                let exp = 2;
                // Now some decagons
                let bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));

                base = base.tr(p(bounds.minPoint.x, bounds.minPoint.y).neg);
                canvas.width = (bounds.maxPoint.x - bounds.minPoint.x) * scale;
                canvas.height = (bounds.maxPoint.y - bounds.minPoint.y) * scale;

                bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));
                bounds = new Bounds();
                const img = canvas.toDataURL("img.png");
            }

            function drawImage() {
                const canvas = document.createElement("canvas");
                canvas.width = 0;
                canvas.height = 0;

                const g = canvas.getContext("2d");
                g.strokeStyle = penrose.OUTLINE;
                g.lineWidth = 1;
                const scale = 5;
                const shapeMode = MODE_REAL;
                const { deca } = iface(g, scale, shapeMode);

                // Now some decagons
                let fifths = 0;
                let isDown = false;
                let base = p(0, 0);
                let exp = 1;
                let bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));
                bounds.pad(1);
                base = base.tr(p(bounds.minPoint.x, bounds.minPoint.y).neg);
                canvas.width = (bounds.maxPoint.x - bounds.minPoint.x) * scale;
                canvas.height = (bounds.maxPoint.y - bounds.minPoint.y) * scale;

                bounds = new Bounds();
                bounds.expand(deca(fifths, isDown, base, exp));
                bounds.pad(1);
                bounds = new Bounds();
                const img = canvas.toDataURL("img.png");
                const ele = document.querySelector("#image");
                ele.src = img;
            }
        </script>
    </body>
</html>
